[{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"initialising","dir":"Articles","previous_headings":"","what":"Initialising","title":"Getting Started","text":"initialise ctsmTMB model object using Printing model object console reveals basic information :","code":"library(ctsmTMB) model <- ctsmTMB$new() print(model) ## This ctsmTMB model contains:               ## States       0 ## Diffusions   0 ## Observations 0 ## Inputs       1 ## Parameters   0"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"add-system-equations","dir":"Articles","previous_headings":"","what":"Add system equations","title":"Getting Started","text":"First specify stochastic differential equation governing latent state xtx_t. straight-forward using R formulas, choosing appropriate character names parameters. emphasize drift terms must multiplied dt diffusion terms dw dw# # number e.g. dw2. single state equation may contain number diffusion terms .e.","code":"model$addSystem(dx ~ theta * (mu - x) * dt + sigma_x * dw) model$addSystem(dx ~ theta * (mu - x) * dt + sigma_x1 * dw1 + x * sigma_x2 * dw2 + dw3)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"add-observation-equations","dir":"Articles","previous_headings":"","what":"Add observation equations","title":"Getting Started","text":"Now observation equations system must specified. amounts specifying mean variance residual normal distribution. First mean specified .e. variable used left-hand side, y, determines name relevant observations -provided data maximum likelihood estimation later.","code":"model$addObs(y ~ x)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"add-observation-variances","dir":"Articles","previous_headings":"","what":"Add observation variances","title":"Getting Started","text":"Next specify residual variance, using name given observation equation , addObs:","code":"model$setVariance(y ~ sigma_y^2 * u)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"add-inputs","dir":"Articles","previous_headings":"","what":"Add inputs","title":"Getting Started","text":"Next, declare variables time-dependent inputs via shall must also provided data later, similar observations.","code":"model$addInput(u)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"add-parameters","dir":"Articles","previous_headings":"","what":"Add parameters","title":"Getting Started","text":"must also specify (fixed effects) parameters, addition initial/lower/upper values estimation. parameter can fixed supplying just single value. instance typically useful fix observation noise parameters simultaneous identification observation process noise difficult practice, knowledge observation noise may known. Thus, let us fix σy\\sigma_{y} somewhat arbitrary reasonable value: Let’s inspect model object , see longer empty:","code":"model$setParameter(   theta   = c(initial = 5,    lower = 0,    upper = 20),   mu      = c(initial = 0,    lower = -10,  upper = 10),   sigma_x = c(initial = 1e-1, lower = 1e-5, upper = 5),   sigma_y = c(initial = 1e-1, lower = 1e-5, upper = 5) ) model$setParameter(   sigma_y  = 0.05 ) print(model) ## This ctsmTMB model contains:               ## States       1 ## Diffusions   1 ## Observations 1 ## Inputs       2 ## Parameters   4 ##  ## System Equations: ##   dx ~ theta * (mu - x) * dt + sigma_x * dw  ##  ## Observation Equations: ##   y:  y ~ x + e   e ~ N(0, sigma_y^2 * u)  ##  ## Inputs: ##   u ##  ## Parameters: ##   theta, mu, sigma_x, sigma_y ##  ## Fixed Parameters: ##   sigma_y"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"set-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set initial state and covariance","title":"Getting Started","text":"Lastly state distribution initial time point must specified via mean variance. Note higher dimensions provided covariance cov must matrix. simple initial covariance just scaled identity e.g. two dimensions cov = 1e-1 * diag(2)","code":"initial.state <- list(mean=1, cov=1e-1) model$setInitialState(initial.state=initial.state)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"generate-data","dir":"Articles","previous_headings":"","what":"Generate Data","title":"Getting Started","text":"model now fully specified, state parameter estimation can performed data hand. particular example generate fake data. can achieved simulating stochastic realization stochastic differential equation, adding observation noise . achieve task using simulate method model object, perform stochastic simulations based Euler-Maruyama scheme. user referred simulation vignette details. choose true parameters θ=10.0μ=1.00σx=1.00σy=0.05 \\theta = 10.0 \\qquad \\mu=1.00 \\qquad \\sigma_{x} = 1.00 \\qquad \\sigma_{y}=0.05 code performs simulation prepares data likelihood estimation:","code":"library(ggplot2)  # Set simulation settings set.seed(11) true.pars <- c(theta=10, mu=1, sigma_x=1, sigma_y=0.05) dt.sim <- 1e-3 t.end <- 5 t.sim <- seq(0, t.end, by=dt.sim) df.sim <- data.frame(t=t.sim, u=1, y=NA)  # Perform simulation sim <- model$simulate(data=df.sim,                        pars=true.pars,                        n.sims=1,                        silent=T,                        initial.state=initial.state) x <- sim$states$x$i0$x1  # Extract observations from simulation and add noise iobs <- seq(1,length(t.sim), by=10) t.obs <- t.sim[iobs] y = x[iobs] + true.pars[\"sigma_y\"] * rnorm(length(iobs))  # Create data-frame data <- data.frame(   t = t.obs,   u = 1,   y = y )  # Plot the simulation and observed data ggplot() +   geom_line(aes(x=t.sim,y=x,color=\"Simulation\")) +   geom_point(aes(x=t.obs,y=y,fill=\"Observations\")) +   ctsmTMB:::getggplot2theme() + labs(x=\"t\", y=\"x\",color=\"\",fill=\"\")"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"perform-estimation","dir":"Articles","previous_headings":"","what":"Perform estimation","title":"Getting Started","text":"can now pass data estimate method. build model, perform various checks, construct computational graph automatic differentiation, perform optimization. Note: data must contain increasing time column named t columns specified inputs observations, case u y. Note: time-consuming step estimation procedure construction AD graph underlying likelihood function, time spent task relative optimization time even models parameters. output generated optimization objective (negative log-likelihood) value parameter values current step. optimizer used ctsmTMB nlminb optimizer stats library. refer user estimation vignette details available arguments estimate, ‘use another optimizer’ vignette details use another optimizer nlminb.","code":"fit <- model$estimate(data) ## Checking and setting data... ## Constructing objective function and derivative tables... ## Minimizing the negative log-likelihood... ##   0:     7625.6873:  5.00000  0.00000 0.100000 ##  10:    -384.86492:  7.81233  1.12328  1.01154 ##   Optimization finished!: ##             Elapsed time: 0.013 seconds. ##             The objective value is: -3.870659e+02 ##             The maximum gradient component is: 1.2e-04 ##             The convergence message is: relative convergence (4) ##             Iterations: 17 ##             Evaluations: Fun: 20 Grad: 18 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished!"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"inspecting-the-fit-object","dir":"Articles","previous_headings":"","what":"Inspecting the fit object","title":"Getting Started","text":"fit object contains following entries first boolean indicates whether estimation successful just copy optimization message stats::nlminb. second likelihood value found optimum third likelihood gradient optimum fourth likelihood hessian optimum","code":"names(fit) ##  [1] \"convergence\"  \"nll\"          \"nll.gradient\" \"nll.hessian\"  \"par.fixed\"    ##  [6] \"sd.fixed\"     \"cov.fixed\"    \"tvalue\"       \"Pr.tvalue\"    \"states\"       ## [11] \"residuals\"    \"observations\" \"private\" fit$convergence ## [1] 0 fit$nll ## [1] -387.0659 fit$nll.gradient ##         theta            mu       sigma_x  ## -3.161067e-06 -1.208976e-04 -4.518894e-05 fit$nll.hessian ##              theta          mu     sigma_x ## theta    0.2720836   0.1521370  -4.8642930 ## mu       0.1521370 469.9827505   0.7193716 ## sigma_x -4.8642930   0.7193716 553.4547321"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"parameter-estimates","dir":"Articles","previous_headings":"Inspecting the fit object","what":"Parameter estimates","title":"Getting Started","text":"Printing fit object reveals standard coefficient matrix parameter estimates. can see parameter estimate associated standard error together one-dimensional t-test statistic associated P-value common hypothesis test $$ H_{0}: p = 0 \\\\ H_{1}: p \\neq 0 $$ Note large uncertainty θ\\theta primarily caused relatively short time-series (2 seconds), relative characteristic time process τ=1/θ=0.1sec\\tau = 1/\\theta = 0.1 \\, \\text{sec}. parameter-related information can extracted fit object. estimated (fixed) parameters: standard deviations (fixed) parameters: covariance (fixed) parameters: parameter covariance found inverting likelihood hessian found optimum .e.:","code":"print(fit) ## Coefficent Matrix  ##         Estimate Std. Error t value  Pr(>|t|)     ## theta   9.199369   2.088424  4.4049 1.296e-05 *** ## mu      1.064966   0.046133 23.0848 < 2.2e-16 *** ## sigma_x 0.946988   0.046301 20.4529 < 2.2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 fit$par.fixed ##     theta        mu   sigma_x  ## 9.1993693 1.0649661 0.9469882 fit$sd.fixed ##      theta         mu    sigma_x  ## 2.08842441 0.04613283 0.04630096 fit$cov.fixed ##                theta            mu       sigma_x ## theta    4.361516497 -1.470533e-03  3.833512e-02 ## mu      -0.001470533  2.128238e-03 -1.569071e-05 ## sigma_x  0.038335117 -1.569071e-05  2.143779e-03 solve(fit$nll.hessian) ##                theta            mu       sigma_x ## theta    4.361516497 -1.470533e-03  3.833512e-02 ## mu      -0.001470533  2.128238e-03 -1.569071e-05 ## sigma_x  0.038335117 -1.569071e-05  2.143779e-03"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"state-estimates","dir":"Articles","previous_headings":"Inspecting the fit object","what":"State estimates","title":"Getting Started","text":"optimal state distributions associated estimated parameters can extracted model object well. example used Extended Kalman filter (default filtering algorithm specified argument method=\"ekf\" estimate). method produces prior posterior state estimates. prior estimates one-step-ahead predictions, posterior estimated priors updated current-time available observations. user referred Kalman Filter vignette information theoretical details. states can easily plotted using provided S3 plot.ctsmTMB.fit method. plot prior posterior states observations: Note: decrease variance posterior state estimate expected states updated observations.","code":"plot(fit, type=\"states\",state.type=\"prior\",against=\"y\") plot(fit, type=\"states\",state.type=\"posterior\",against=\"y\")"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"residual-analysis","dir":"Articles","previous_headings":"Inspecting the fit object","what":"Residual analysis","title":"Getting Started","text":"Model validation typically involves inspecting properties prediction residuals. model residuals contained fit$residuals entries: can also easily generate residual analysis plot S3 plot.ctsmTMB.fit method. actually default arguments plot.ctsmTMB.fit. produces time-series residuals, histogram, quantile-quantile plot, auto/partial-correlations cumulative periodogram:","code":"names(fit$residuals) ## [1] \"residuals\"  \"sd\"         \"normalized\" \"cov\" plot(fit)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"profiling-the-likelihood","dir":"Articles","previous_headings":"","what":"Profiling the likelihood","title":"Getting Started","text":"can perform likelihood profiling profile S3 method fit object, plot result calling plot S3 method . example can inspect profile likelihood θ\\theta follows:","code":"a <- fit$par.fixed[\"theta\"] - 3*fit$sd.fixed[\"theta\"] b <- fit$par.fixed[\"theta\"] + 3*fit$sd.fixed[\"theta\"] prof <- profile(fit, list(\"theta\"=seq(a,b,length.out=50)), silent=TRUE) plot(prof) # a <- fit$par.fixed[\"mu\"] - 8*fit$sd.fixed[\"mu\"] # b <- fit$par.fixed[\"mu\"] + 8*fit$sd.fixed[\"mu\"] # prof <- profile(fit, list(\"mu\"=seq(a,b,length.out=50)), silent=TRUE) # plot(prof) # a <- fit$par.fixed[\"theta\"] - 5*fit$sd.fixed[\"theta\"] # b <- fit$par.fixed[\"theta\"] + 5*fit$sd.fixed[\"theta\"] # c <- fit$par.fixed[\"mu\"] - 10*fit$sd.fixed[\"mu\"] # d <- fit$par.fixed[\"mu\"] + 10*fit$sd.fixed[\"mu\"] # prof <- profile(fit, list(\"theta\"=seq(a,b,length.out=50), #                           \"mu\"=seq(c,d,length.out=50)), silent=TRUE) # plot(prof)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/ctsmTMB.html","id":"extra-algebraic-equations","dir":"Articles","previous_headings":"","what":"Extra: Algebraic equations","title":"Getting Started","text":"model definitions can kept clean defining algebraic expressions replace variables defined equations. typical scenario algebraic equations can used rename parameters must strictly positive. Example model θ\\theta strictly positive parameter θ̂=exp(logθ)\\hat{\\theta} = \\exp(\\log\\theta). can achieved setting following algebraic expression: effect replace occurrences theta model equations exp(logtheta). final thing add new parameter entry model object describes values logtheta","code":"model$setAlgebraics(theta ~ exp(logtheta)) model$setParameter(logtheta = log(c(initial=5, lower=0, upper=20)))"},{"path":[]},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-method","dir":"Articles","previous_headings":"Arguments","what":"Argument: method","title":"Estimating Parameters","text":"method argument decides estimation/filtering algorithm used. Currently, following methods available: method='lkf': Linear Kalman Filter. method='ekf': Extended Kalman Filter. method='laplace': Laplace Approximation. difference Kalman filtering methods, Laplace method way approach likelihood computations, thus information filters produce: Kalman filters produce prior posterior state estimates. prior estimates conditioned observations starting time t0t_0 til previous time-point tk−1t_{k-1}. posterior estimates conditioned also observations available “current” time-point tkt_{k}. denoted respectively Prior:E[xtk∣ytk−1,ytk−2,...,yt0] \\text{Prior:} \\quad \\mathrm{E}\\left[ x_{t_k} \\mid y_{t_{k-1}}, y_{t_{k-2}},...,y_{t_0} \\right]  Posterior:E[xtk∣ytk,ytk−1,...,yt0] \\text{Posterior:} \\quad \\mathrm{E}\\left[ x_{t_k} \\mid y_{t_{k}}, y_{t_{k-1}},...,y_{t_0} \\right]  Laplace filter produces smoothed state estimates. state estimate based observations time-points t0t_{0} tNt_{N} NN last index time-series. denoted Smoothed:E[xtk∣yN,yN−1,...,ytk,...,yt1,yt0] \\text{Smoothed:} \\quad \\mathrm{E}\\left[ x_{t_k} \\mid y_{N}, y_{N-1},...,y_{t_{k}},...,y_{t_1}, y_{t_0} \\right] likelihood contributions Kalman filters based prior estimates, one-step-ahead predictions. gives rise independent one-step-ahead residuals, ideal residual analysis goodness--fit model validation. Laplace filter produce residuals inherently, must instead compute side. Residual calculations disabled default determined laplace.residuals argument. computations costly slow. user referred documentation TMB::oneStepPredict information.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.solver","title":"Estimating Parameters","text":"argument used Kalman filtering methods determine ODE integrator used solving moment differential equations .e. dE[xt]dt=f(E[xt]) \\dfrac{d\\mathrm{E}\\left[x_t\\right]}{dt} = f(\\mathrm{E}\\left[x_t\\right]) dV[xt]dt=dfdx|(E[xt])V[xt]+V[xt][dfdx|(E[xt])]T+g(E[xt])g(E[xt])T \\dfrac{d\\mathrm{V}\\left[x_t\\right]}{dt} = \\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_t\\right])}\\mathrm{V}\\left[x_t\\right] + \\mathrm{V}\\left[x_t\\right]\\left[\\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_t\\right])}\\right]^{T} + g(\\mathrm{E}\\left[x_t\\right])g(\\mathrm{E}\\left[x_t\\right])^{T}  ctsmTMB package implements Explicit Forward-Euler euler Explicit 4th Order Runge-Kutta rk4 methods.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.timestep","title":"Estimating Parameters","text":"argument two different implications depending whether Kalman filtering Laplace filtering carried . method accepts either single scalar value used global time-step, vector length diff(data$t) specifying individual time-steps. input values interpolated linearly time-points one step taken. Kalman filters: case argument controls time-step used euler rk4 ODE solvers. Laplace filter: case argument controls number added intermediate time-points observations represents additional state (random effect) particular time-point. provided time-step Δti\\Delta t_{} divide correspond time-difference ti+1−tit_{+1}-t_{} data rounded . Consider following example time-difference two observations data 3 seconds, time-step 0.7. produces non-integer number steps .e.: Ni=ti+1−tiΔti=30.7=4.28... N_{} = \\dfrac{t_{+1}-t_{}}{\\Delta t_i} = \\dfrac{3}{0.7} = 4.28...  Thus number steps taken rounded Ni*=⌈Ni⌉=⌈4.28...⌉=5N^{*}_i = \\left\\lceil N_i \\right\\rceil = \\left\\lceil 4.28... \\right\\rceil = 5 corrected time-step becomes Δti*=3Ni*=35=0.6 \\Delta t^{*}_{} = \\dfrac{3}{N^{*}_{}} = \\dfrac{3}{5} = 0.6 Note: exception rule remainder less ϵ=10−3\\epsilon = 10^{-3} .e. instance Ni=4.0001N_i = 4.0001 time-step accepted, number steps rounded Ni*=⌊Ni⌋=4N^{*}_{}= \\left\\lfloor N_i \\right\\rfloor = 4.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-loss-and-loss_c","dir":"Articles","previous_headings":"Arguments","what":"Argument: loss and loss_c","title":"Estimating Parameters","text":"following losses currently available: loss='quadratic' (default) loss='huber' loss='tukey' argument affects Kalman filtering methods, used regularize likelihood contributions, removing influence large outliers. ith likelihood contributions given : −logLi(θ)∝f(ri) -\\log L_{}(\\theta) \\propto f(r_i)  ri=eiTΣi−1eir_i = \\sqrt{e_{}^{T} \\Sigma_{}^{-1} e_{}} normalized residual, eie_{} ith residual vector, Σi−1\\Sigma_{}^{-1} ith residual precision matrix. loss argument changes function ff follows: loss='quadratic' ff quadratic residuals .e. f(r)=r2 f(r) = r^2  likelihood contributions exactly Gaussian. loss='huber' ff Huber’s ψ\\psi function given ψc(r)={r2forr≤cc(2r−c)otherwise} \\psi_{c}(r) = \\left\\{ \\begin{array}{l} r^2 & \\text{} \\,\\, r \\leq c \\\\ c(2r-c) & \\text{otherwise} \\end{array} \\right\\}  quadratic/linear residuals /threshold determined cc. loss='tukey' ff Tukey’s byweight function given lc(r)={r2forr≤cc2otherwise} l_{c}(r) = \\left\\{ \\begin{array}{l}  r^2 & \\text{} \\,\\, r \\leq c  \\\\ c^2 & \\text{otherwise} \\end{array} \\right\\}  quadratic/constant residuals /threshold determined cc. practice smooth approximation Huber Tukey implemented practice using construction ψ̃c(r)=r2(1−σc(r))+c2σc(r) \\tilde{\\psi}_{c}(r) = r^2 (1-\\sigma_{c}(r)) + c^2 \\sigma_{c}(r) l̃c(r)=r2(1−σc(r))+c(2r−c)σc(r) \\tilde{l}_{c}(r) = r^2 (1-\\sigma_{c}(r)) + c(2r-c) \\sigma_{c}(r)  σ(r)\\sigma(r) sigmoid function σc(r)=11+exp(−5(r−c)) \\sigma_{c}(r) = \\dfrac{1}{1+\\exp(-5(r-c))}  plot shows actual implemented loss functions (almost indistinguishable) c=5c=5. threshold value marked dashed line line x=cx = c. Loss Functions loss_c argument used determine value cc. default values chosen based fact assumed (multivariate) normal distribution residuals, squared (normalized) residuals follows χm2\\chi^{2}_{m} distribution degrees freedom equal number elements eie_{} .e: ri2=eiTΣi−1ei∼χm2 r_{}^2 = e_{}^{T} \\Sigma_{}^{-1} e_{} \\sim \\chi^{2}_{m}  therefore reasonable choose threshold level (value cc) determines whether rir_{} outlier, level null-hypothesis H0:ri2∼χm2 H_{0}: r_{}^2 \\sim \\chi^{2}_{m}  rejected critical value 1−α1 - \\alpha. Choosing significance level α=0.05\\alpha = 0.05 appropriate cc threshold value becomes mm number observation equations. Note: significance level higher chosen missing observations indices ii systems multiple observation equations.","code":"m <- 1 qchisq(0.95,df=m) ## [1] 3.841459"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-use_hessian","dir":"Articles","previous_headings":"Arguments","what":"Argument: use_hessian","title":"Estimating Parameters","text":"argument boolean determines whether likelihood hessian constructed automatic differentiation TMB used optimization procedure providing hessian argument stats::nlminb. default use.hessian=FALSE. argument effect method=laplace due restrictions TMB/RTMB. effect providing hessian typically optimum found fewer iterations, cost computing hessian relatively large, often faster optimize using gradient.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-laplace-residuals","dir":"Articles","previous_headings":"Arguments","what":"Argument: laplace.residuals","title":"Estimating Parameters","text":"boolean controls whether model residuals calculated TMB::oneStepPredict Laplace filtering used (method=laplace). takes considerable amount time - typically much longer estimation .","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-unconstrainted-optim","dir":"Articles","previous_headings":"Arguments","what":"Argument: unconstrainted.optim","title":"Estimating Parameters","text":"boolean allows quick unconstrained estimation removing parameter boundaries specified setParameter. may useful sometimes, quickly check whether estimation issues occur ill boundaries.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-estimate-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: estimate.initial.state","title":"Estimating Parameters","text":"boolean determines whether initial-time state distribution (mean covariance) estimated . default estimate.initial.state=FALSE estimated simply taken values provided setInitialState. estimate.initial.state=TRUE mean covariance estimated stationary solution moment differential equations using input values initial time-point. stationary solution obtained first solving dE[x∞]dt=f(E[x∞])=0 \\dfrac{d\\mathrm{E}\\left[x_{\\infty}\\right]}{dt} = f(\\mathrm{E}\\left[x_\\infty\\right]) = 0  E[x∞]\\mathrm{E}\\left[x_\\infty\\right] using Newton’s method. stationary mean used solve dV[x∞]dt=dfdx|(E[x∞])V[x∞]+V[x∞][dfdx|(E[x∞])]T+g(E[x∞])g(E[x∞])T=0 \\dfrac{d\\mathrm{V}\\left[x_\\infty\\right]}{dt} = \\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_\\infty\\right])}\\mathrm{V}\\left[x_\\infty\\right] + \\mathrm{V}\\left[x_\\infty\\right]\\left[\\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_\\infty\\right])}\\right]^{T} + g(\\mathrm{E}\\left[x_\\infty\\right])g(\\mathrm{E}\\left[x_\\infty\\right])^{T} = 0  stationary covariance V[x∞]\\mathrm{V}\\left[x_\\infty\\right] calling linear solver vectorized system equations (using kronecker products).","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-control","dir":"Articles","previous_headings":"Arguments","what":"Argument: control","title":"Estimating Parameters","text":"argument list controls various settings stats::nlminb optimizer. See documentation ?stats::nlminb information. default list(trace=1,iter.max=1e5,eval.max=1e5) prints iteration steps, increases default number iterations function calls allowed optimization procedure terminates. Note:: user remember disabling tracing passing control = list(trace=0) remove ìter.maxand eval.max arguments, provided well needed.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"argument-silent","dir":"Articles","previous_headings":"Arguments","what":"Argument: silent","title":"Estimating Parameters","text":"boolean argument controls whether various information messages printed ctsmTMB model building, compilation estimation.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/estimate.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Estimating Parameters","text":"Insert Example","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/observation_equations.html","id":"adding-observation-equations","dir":"Articles","previous_headings":"","what":"Adding observation equations","title":"AddObs - Details","text":"Let’s assume observations yty_{t} log-normally distributed conditioned xtx_{t} .e. logyti∼N(xti,σy2) \\log y_{t_{}} \\sim N(x_{t_{}},\\sigma_{y}^{2})  sufficient user provide data column y provided data.frame e.g. estimate predict adding following observation equation Note kind observation equations, left-hand side function one () observed variables must explicitly named using obsnames argument.","code":"obj$addObs(   log(y) ~ x, obsnames = \"log_y\" )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/observation_equations.html","id":"adding-observation-variances","dir":"Articles","previous_headings":"","what":"Adding observation variances","title":"AddObs - Details","text":"names given obsnames important needed specify observation variance. example code work, observation named log_y correct way add observation variance :","code":"obj$setVariance(   y ~ sigma_y^2 ) ## Error in check_observation_variance_eqs(form, self, private): Please add an observation equation for y before specifying its variance obj$setVariance(   log_y ~ sigma_y^2 )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/observation_equations.html","id":"multiple-observation-equations","dir":"Articles","previous_headings":"","what":"Multiple observation equations","title":"AddObs - Details","text":"must supply multiple obsnames supplying multiple observation equations, although name used left-hand side just single variable .e.","code":"obj$addObs(   log(y) ~ x,   y ~ x,   y^2+z^3 ~ x,   obsnames = c(\"log_y\", NA, \"y2_plus_z3\") )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"notation","dir":"Articles","previous_headings":"","what":"Notation","title":"Moment Predictions","text":"Let set observations initial time t0t_0 current time tit_{} noted 𝒴i={yi,yi−1,...,y1,y0} \\mathcal{Y}_{} = \\left\\{ y_{}, y_{-1},...,y_{1},y_{0}\\right\\}  k-step prediction prior estimate state mean covariance k time-steps “future” (without updating observations along way) .e.: $$ \\hat{x}_{+k|} = \\mathrm{E}\\left[ x_{t_{+k}} | y_{t_{}} \\right] \\\\ \\hat{P}_{+k|} = \\mathrm{V}\\left[ x_{t_{+k}} | y_{t_{}} \\right] $$ obtain predictions integrating moment differential equations (linear ff) forward time .e: $$ \\hat{x}_{+k|} = \\hat{x}_{|} + \\int_{t_{}}^{t_{+k}} f(\\hat{x}_{}(\\tau)) \\, d\\tau \\\\ \\hat{P}_{+k|} = \\hat{P}_{|} + \\int_{t_{}}^{t_{+k}} (\\hat{x}_{}(\\tau)) \\hat{P}_{}(\\tau) + \\hat{P}_{}(\\tau) ^{T}(\\hat{x}_{}(\\tau)) + G(\\hat{x}_{}(\\tau)) G^{T}(\\hat{x}_{}(\\tau)) \\, d\\tau $$ x̂(τ)=E[xτ|yti]\\hat{x}_{}(\\tau) = \\mathrm{E}\\left[ x_{\\tau} | y_{t_{}} \\right] P̂(τ)=V[xτ|yti]\\hat{P}_{}(\\tau) = \\mathrm{V}\\left[ x_{\\tau} | y_{t_{}} \\right], =dfdxA = \\dfrac{df}{dx}","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"arguments","dir":"Articles","previous_headings":"","what":"Arguments","title":"Moment Predictions","text":"predict method accepts following arguments","code":"model$predict(data,               pars = NULL,               method = \"ekf\",               ode.solver = \"rk4\",               ode.timestep = diff(data$t),               k.ahead = nrow(data)-1,               return.k.ahead = 0:k.ahead,               return.covariance = TRUE,               initial.state = self$getInitialState(),               estimate.initial.state = private$estimate.initial,               use.cpp = FALSE,               silent = FALSE,               ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-pars","dir":"Articles","previous_headings":"Arguments","what":"Argument: pars","title":"Moment Predictions","text":"argument vector parameter values, used generate predictions. default behaviour use parameters obtained latest call estimate () alternative use initial guesses defined setParameter.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-use-cpp","dir":"Articles","previous_headings":"Arguments","what":"Argument: use.cpp","title":"Moment Predictions","text":"argument boolean determines whether pure R (use.cpp=FALSE, default) C++ (use.cpp=TRUE) implementation used calculate predictions. advantage C++ implementation computational speed comes cost 5-10 seconds compilation time (first time session C++ implementation used, subsequent calls faster). number prediction steps compute given maximized k.ahead = nrow(data)/2. C++ implementation therefore typically advantageous (relatively large) range around maximum, least data sufficiently many rows.","code":"k.ahead * (nrow(data) - k.ahead)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-method","dir":"Articles","previous_headings":"Arguments","what":"Argument: method","title":"Moment Predictions","text":"See description estimate vignette. Note: predict method currently available using Extended Kalman filter (method=\"ekf).","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.solver","title":"Moment Predictions","text":"See description estimate vignette. Note: argument use.cpp=TRUE solvers available euler rk4.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.timestep","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: k.ahead","title":"Moment Predictions","text":"integer argument determines number prediction steps desired.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-return-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: return.k.ahead","title":"Moment Predictions","text":"vector integers determines k-step predictions returned. default behaviour return prediction steps (determined k.ahead).","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-return-covariance","dir":"Articles","previous_headings":"Arguments","what":"Argument: return.covariance","title":"Moment Predictions","text":"boolean argument determines whether covariance (return.covariance=TRUE, default) prediction correlations returned. returned diagonal elements always variances, trivial 1’s correlation matrix.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: initial.state","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-estimate-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: estimate.initial.state","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"argument-silent","dir":"Articles","previous_headings":"Arguments","what":"Argument: silent","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Moment Predictions","text":"consider modified Ornstein Uhlenbeck process: $$ \\mathrm{d}x_{t} = \\theta (a_t - x_{t}) \\, \\mathrm{d}t \\, + \\sigma_{x} \\, \\mathrm{d}b_{t} \\\\ y_{t_{k}} = x_{t_{k}} + \\varepsilon_{t_{k}} $$ mean complex time-varying input =tut2−cos(tut)a_t = tu_{t}^{2}-\\cos(tu_{t}), utu_{t} given time-varying input signal. create model simulate data follows: true parameters θ=20σx=1.00σy=0.05 \\theta = 20 \\qquad \\sigma_{x} = 1.00 \\qquad \\sigma_{y}=0.05 data plotted : good starting point using predictions, check appropriate parameter values, may provided setParameter good initial guesses optimization. Note however setParameter must called order predict callable (parameter names model needs identified), parameter values can changed calling predict. Let’s calculate predictions series parameter values (changing theta): Note: default behaviour predict use “full” prediction horizon e.g. k.ahead big possible (k.ahead = nrow(.data)-1), using parameters setParameter case pars=c(2,1,1): output predict list two data.frames, one states one observations. five first columns two data.frames identical - contain columns j (indices), associated time-points t.t.j, k.ahead. remaining columns states mean predictions, associated covariances. observations data.frame currently contain mean estimates, obtained passing mean state estimates observation function, case y=h(x)=xy = h(x) = x. actual observed data also provided suffix .data. plot predictions data can perhaps identify θ∈[10,50]\\theta \\\\left[10,50\\right] (θ=20\\theta=20 truth ).","code":"model = ctsmTMB$new() model$addSystem(dx ~ theta * (t*u^2-cos(t*u) - x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 2, lower = 0,    upper = 100),   sigma_x = c(initial = 0.2, lower = 1e-5, upper = 5),   sigma_y = c(initial = 5e-2) ) model$setInitialState(list(1, 1e-1*diag(1)))  # Set simulation settings set.seed(20) true.pars <- c(theta=20, sigma_x=1, sigma_y=5e-2) dt.sim <- 1e-3 t.sim <- seq(0, 1, by=dt.sim) u.sim <- cumsum(rnorm(length(t.sim),sd=0.1)) df.sim <- data.frame(t=t.sim, y=NA, u=u.sim)  # Perform simulation set.seed(1) sim <- model$simulate(data=df.sim,                        pars=true.pars,                        n.sims=1,                       silent=T) x <- sim$states$x$i0$x1  # Extract observations from simulation and add noise iobs <- seq(1,length(t.sim), by=10) t.obs <- t.sim[iobs] u.obs <- u.sim[iobs] y = x[iobs] + true.pars[\"sigma_y\"] * rnorm(length(iobs))  # Create data-frame .data <- data.frame(   t = t.obs,   u = u.obs,   y = y ) pred = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(1, 1, 0.05)) pred1 = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(10, 1, 0.05)) pred2 = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(50, 1, 0.05)) pred3 = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(100, 1, 0.05)) head(pred$states) ##   i. j. t.i  t.j k.ahead         x       var.x ## 1  0  0   0 0.00       0 0.8609702 0.002439024 ## 2  0  1   0 0.01       1 0.8424560 0.012291392 ## 3  0  2   0 0.02       2 0.8241425 0.021948669 ## 4  0  3   0 0.03       3 0.8061096 0.031414720 ## 5  0  4   0 0.04       4 0.7884036 0.040693330 ## 6  0  5   0 0.05       5 0.7708617 0.049788211 head(pred$observations) ##   i. j. t.i  t.j k.ahead         y      y.data ## 1  0  0   0 0.00       0 0.8609702  0.85749450 ## 2  0  1   0 0.01       1 0.8424560  0.53275236 ## 3  0  2   0 0.02       2 0.8241425  0.36195951 ## 4  0  3   0 0.03       3 0.8061096  0.08600299 ## 5  0  4   0 0.04       4 0.7884036 -0.20059967 ## 6  0  5   0 0.05       5 0.7708617 -0.17367966"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/predict.html","id":"forecasting-evaluation","dir":"Articles","previous_headings":"","what":"Forecasting Evaluation","title":"Moment Predictions","text":"can evaluate forecast performance model comparing predictions observed data. start estimating likely parameters model: predict appropriate forecast horizon. example let horizon 25-steps: Let’s plot 10-step predictions observations.  Lastly lets calculate mean prediction accuracy using RMSE-score:","code":"fit = model$estimate(.data) ## Checking and setting data... ## Constructing objective function and derivative tables... ## Minimizing the negative log-likelihood... ##   0:     750.31946:  2.00000 0.200000 ##  10:    -81.800520:  17.4045 0.937931 ##   Optimization finished!: ##             Elapsed time: 0.003 seconds. ##             The objective value is: -8.182203e+01 ##             The maximum gradient component is: 1.2e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 16 ##             Evaluations: Fun: 18 Grad: 17 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! print(fit) ## Coefficent Matrix  ##          Estimate Std. Error t value  Pr(>|t|)     ## theta   17.499148   1.432994 12.2116 < 2.2e-16 *** ## sigma_x  0.919452   0.098126  9.3701 2.589e-15 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 pred.horizon <- 25 pred = model$predict(.data, k.ahead=pred.horizon) ## Checking and setting data... ## Predicting with R... ## Returning results... ## Finished! pred.H = pred$states[pred$states$k.ahead==pred.horizon,] pdf <- cbind(pred$states, y.data = pred$observations$y.data) rmse <- data.frame(   k.ahead = 0:pred.horizon,   rmse = sapply(split(pdf, pdf$k.ahead), function(df) {     sqrt(mean((df$x - df$y.data)^2, na.rm = TRUE))   }) )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"notation","dir":"Articles","previous_headings":"","what":"Notation","title":"Stochastic Simulations","text":"Let set observations initial time t0t_0 current time tit_{} noted 𝒴i={yi,yi−1,...,y1,y0} \\mathcal{Y}_{} = \\left\\{ y_{}, y_{-1},...,y_{1},y_{0}\\right\\} k-step simulation sample stochastic path model stochastic differential equation k time-steps future, conditioned current state estimate mean covariance $$ \\hat{x}_{|} = \\mathrm{E}\\left[ x_{t_{}} | y_{t_{}} \\right] \\\\ P_{|} = \\mathrm{V}\\left[ x_{t_{}} | y_{t_{}} \\right] $$ single stochastic simulation can obtained using Euler-Maruyama scheme Xtj+1=Xtj+f(Xtj,utj,tj)Δtj+G(Xtj,utj,tj)ΔBj X_{t_{j+1}} = X_{t_{j}} + f(X_{t_{j}},u_{t_{j}},t_{j}) \\, \\Delta t_{j} + G(X_{t_{j}},u_{t_{j}},t_{j}) \\, \\Delta B_{j}  j=,...,+kj=,...,+k, initial point follows Xti∼N(x̂|,Pi|) X_{t_{}} \\sim N(\\hat{x}_{|}, P_{|} )  ΔBj∼N(0,Δtj) \\Delta B_{j} \\sim N(0,\\Delta t_{j})","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"arguments","dir":"Articles","previous_headings":"","what":"Arguments","title":"Stochastic Simulations","text":"simulate method accepts following arguments","code":"model$simulate(data,                pars = NULL,                use.cpp = FALSE,                method = \"ekf\",                ode.solver = \"rk4\",                ode.timestep = diff(data$t),                simulation.timestep = diff(data$t),                k.ahead = nrow(data)-1,                return.k.ahead = 0:k.ahead,                n.sims = 100,                initial.state = self$getInitialState(),                estimate.initial.state = private$estimate.initial,                silent = FALSE)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-pars","dir":"Articles","previous_headings":"Arguments","what":"Argument: pars","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-use-cpp","dir":"Articles","previous_headings":"Arguments","what":"Argument: use.cpp","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-method","dir":"Articles","previous_headings":"Arguments","what":"Argument: method","title":"Stochastic Simulations","text":"See description estimate vignette. Note: simulate method currently available using Extended Kalman filter (method=\"ekf).","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.solver","title":"Stochastic Simulations","text":"See description estimate vignette. Note: argument use.cpp=TRUE solvers available euler rk4.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.timestep","title":"Stochastic Simulations","text":"See description estimate vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: k.ahead","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-return-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: return.k.ahead","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-simulation-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: simulation.timestep","title":"Stochastic Simulations","text":"argument ode.timestep determines time-steps used data-points performing Euler-Maruyama simulation.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-n-sims","dir":"Articles","previous_headings":"Arguments","what":"Argument: n.sims","title":"Stochastic Simulations","text":"number stochastic simulations (trajectories) generated.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: initial.state","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-estimate-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: estimate.initial.state","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"argument-silent","dir":"Articles","previous_headings":"Arguments","what":"Argument: silent","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/simulate.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Stochastic Simulations","text":"consider modified Ornstein Uhlenbeck process: $$ \\mathrm{d}x_{t} = \\theta (a_t - x_{t}) \\, \\mathrm{d}t \\, + \\sigma_{x} \\, \\mathrm{d}b_{t} \\\\ y_{t_{k}} = x_{t_{k}} + \\varepsilon_{t_{k}} $$ mean complex time-varying input =tut2−cos(tut)a_t = tu_{t}^{2}-\\cos(tu_{t}), utu_{t} given time-varying input signal. create model simulate data follows: can simulate many trajectories using: parameters θ=20,σx=1,σy=0.05\\theta = 20, \\sigma_{x} = 1, \\sigma_{y} = 0.05. Note: value σy\\sigma_{y} impact “full” simulations (.e. choosing maximum k.ahead) since data updates occur. simulations can plotted quickly using matplot:  Lets see effect setting σx=3\\sigma_{x} = 3:  Lets see effect setting θ=50\\theta = 50:","code":"model = ctsmTMB$new() model$addSystem(dx ~ theta * (t*u^2-cos(t*u) - x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 2, lower = 0,    upper = 100),   sigma_x = c(initial = 0.2, lower = 1e-5, upper = 5),   sigma_y = c(initial = 5e-2) ) model$setInitialState(list(1, 1e-1*diag(1))) # Set simulation settings set.seed(20) true.pars <- c(theta=20, sigma_x=1, sigma_y=5e-2) dt.sim <- 1e-3 t.sim <- seq(0, 1, by=dt.sim) u.sim <- cumsum(rnorm(length(t.sim),sd=0.1)) df.sim <- data.frame(t=t.sim, y=NA, u=u.sim)  # Simulate data sim <- model$simulate(data=df.sim,                        pars=true.pars,                        n.sims=1,                       silent=T)  # Grab first simulation trajectory x <- sim$states$x$i0$x1  # Extract observations from simulation and add noise iobs <- seq(1,length(t.sim), by=10) t.obs <- t.sim[iobs] u.obs <- u.sim[iobs] y = x[iobs] + true.pars[\"sigma_y\"] * rnorm(length(iobs))  # Create data-frame .data <- data.frame(   t = t.obs,   u = u.obs,   y = y ) sim <- model$simulate(data=.data,                        pars=c(20,1,0.05),                        n.sims=100,                       silent=T) # Get the first (and only in this case) k-step simulation data.frame X <- sim$states$x$i0  # Grab all the simulations (the first five columns are indices, time, etc.) Y <- X[,-c(1:5)]  # Grab prediction time column t <- X[,\"t.j\"]  # Plot matplot(t,Y,type=\"l\", ylim=c(-4,4)) sim <- model$simulate(data=.data,                        pars=c(20,3,0.05),                        n.sims=100,                       silent=T) sim <- model$simulate(data=.data,                        pars=c(50,1,0.05),                        n.sims=100,                       silent=T)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Extracting the Likelihood Function and Changing Optimizer","text":"use common Ornstein-Uhlenbeck process showcase use likelihood. dXt=θ(μ−Xt)dt+σXdBt \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} Ytk=Xtk+etk,etk∼𝒩(0,σY2) Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)    first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Extracting the Likelihood Function and Changing Optimizer","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Extracting the Likelihood Function and Changing Optimizer","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Checking model components... ## Checking and setting data... ## Constructing objective function and derivative tables... ## Minimizing the negative log-likelihood... ##   0:     921.77031:  1.60944  0.00000 -2.30259 -2.30259 ##  10:    -38.611349:  2.53386  1.03053 0.151828 -2.34627 ##   Optimization finished!: ##             Elapsed time: 0.004 seconds. ##             The objective value is: -3.934664e+01 ##             The maximum gradient component is: 1.3e-04 ##             The convergence message is: relative convergence (4) ##             Iterations: 19 ##             Evaluations: Fun: 27 Grad: 20 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! nll = TMB::MakeADFun(...) opt = stats::nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"Extracting the Likelihood Function and Changing Optimizer","text":"likelihood method allows retrieve nll object holds negative log-likelihood, derivatives. method takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluated gradient can evaluated hessian can evaluated can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$likelihood(.data) ## Finished! nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 921.7703 nll$gr(nll$par) ##          [,1]      [,2]      [,3]      [,4] ## [1,] 1382.854 -1557.574 -1191.374 -820.9253 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2226.705 -2859.2069 -1636.0560 -1136.3013 ## [2,] -2859.207  1663.1457  2251.5926   865.5807 ## [3,] -1636.056  2251.5926   905.1284  1486.3607 ## [4,] -1136.301   865.5807  1486.3607   346.7711"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"Extracting the Likelihood Function and Changing Optimizer","text":"can extract parameter bounds specified calling setParameter() method using getParameters method (note nll$par pars$initial identical).","code":"pars = obj$getParameters() print(pars) ##            type   estimate   initial     lower     upper ## logtheta   free  2.8028461  1.609438      -Inf  2.995732 ## mu         free  1.0774793  0.000000 -10.00000 10.000000 ## logsigma_x free  0.2024819 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.3269231 -2.302585 -11.51293  1.609438"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"Extracting the Likelihood Function and Changing Optimizer","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/articles/using_another_optimizer.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"Extracting the Likelihood Function and Changing Optimizer","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external   internal ## logtheta    2.8028428  2.8028461 ## mu          1.0774788  1.0774793 ## logsigma_x  0.2024796  0.2024819 ## logsigma_y -2.3269222 -2.3269231 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -39.34664 -39.34664 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1 -5.284383e-05 -2.269770e-06 ## 2 -1.491876e-04 -1.337658e-04 ## 3 -4.592109e-05  2.628658e-05 ## 4 -2.656532e-05 -2.239568e-06"},{"path":"https://github.com/phillipbvetter/ctsmTMB/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Phillip Vetter. Author, maintainer, copyright holder. Jan Møller. Contributor. Uffe Thygesen. Contributor. Peder Bacher. Contributor. Henrik Madsen. Contributor.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vetter PB, Møller JK, Thygesen U, Bacher P, Madsen H (2025). ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder. R Package Version 1.0, https://github.com/phillipbvetter/ctsmTMB.","code":"@Manual{,   title = {ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder},   author = {Phillip Brinck Vetter and Jan K. Møller and Uffe Thygesen and Peder Bacher and Henrik Madsen},   year = {2025},   note = {R Package Version 1.0},   url = {https://github.com/phillipbvetter/ctsmTMB}, }"},{"path":[]},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"Welcome GitHub repository hosts ctsmTMB (Continuous Time Stochastic Modelling using Template Model Builder), intended successor , heavily inspired , CTSM package (Continuous Time Stochastic Modelling). purpose package facilitate user-friendly tool (state parameter) inference, forecasting, (multi-dimensional) continuous-discrete stochastic state space systems, .e. systems form dxt=f(t,xt,ut,p)dt+g(t,xt,ut,p)dBt dx_{t} = f\\left( t, x_t, u_t, p \\right) dt + g\\left( t, x_t, u_t, p \\right) dB_{t} yk=h(tk,xtk,utk,p) y_{k} = h\\left( t_k, x_{t_k}, u_{t_k}, p \\right) latent state xtx_t evolves continuously time, governed set stochastic differential equations, information system available discrete times tkt_{k} observations yky_{k}. ctsmTMB package essentially wrapper around TMB/RTMB packages (Template Model Builder) provide automatic differentiation likelihood function, access computational tools Laplace approximation. likelihood function constructed based (symbolic) user-provided state space equations, may specified using implemented OOP-style R6 ctsmTMB class, methods addSystem (defining system equations), addObs (defining observation equations). primary work-horse ctsmTMB estimate method, carries inference minimizing (negative log) likelihood using stats::nlminb quasi-Newton optimizer. resulting object contains maximum likelihood parameter state estimates, associated marginal uncertainties. available inference methods Linear Extended Kalman filters addition filtration (actually smoothing) using Laplace approximation approach. package facilities forecasting predict (moment forecasts) simulate (stochastic path simulations) methods. calculations may carried either R (default) additional speed C++ using Rcpp.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"estimation-methods","dir":"","previous_headings":"","what":"Estimation Methods","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"following state reconstruction algorithms currently available: Linear Kalman Filter, lkf. Extended Kalman Filter, ekf. Unscented Kalman Filter, ukf. Laplace Smoothers laplace laplace.thygesen.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"kalman-filters","dir":"","previous_headings":"","what":"Kalman Filters","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"package currently mostly tailored towards Kalman Filter. advantages methods : hessian likelihood function (w.r.t fixed parameters) available. model residuals easier compute e.g. model validation. Multi-step predictions / simulations state updates easier compute. Unscented Kalman Filter implementation based Algorithm 4.7 S. Särkkä, 2007.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"laplace-smoother","dir":"","previous_headings":"","what":"Laplace Smoother","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"state-reconstructions based laplace (approximation) method smoothed estimates, meaning states optimized jointly conditioned observations. Laplace approximation natively built-completely handled TMB. additional method laplace.thygesen implementation stability-improved laplace method systems state-dependent diffusion due Thygesen, 2025. particular advantage Laplace smoother : possibility unimodal non-Gaussian observation densities accommodate need e.g. heavier distribution tails. yet implemented.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"installation-compilers","dir":"","previous_headings":"","what":"Installation (Compilers)","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"NOTE: NEED MAKE SURE WORKING C++ COMPILER R INSTALL PACKAGE!!","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"windows","dir":"","previous_headings":"","what":"Windows","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"C++ compilation R requires Rtools: Go https://cran.r-project.org/bin/windows/Rtools/ find latest version. Go “Control Panel -> System ->”Advanced” (tab) -> “Environment Variables” -> Highlight “Path” -> “Edit” -> Add character string “Variable Value” path Rtools folder **C:;C:*.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"mac--unix","dir":"","previous_headings":"","what":"Mac / Unix","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"Mac users install Command Line Tools. Run following command Terminal","code":"xcode-select --install"},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"installation-package","dir":"","previous_headings":"","what":"Installation (Package)","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"package can installed source CRAN: development version available GitHub R-universe: encounter problems locked folder 00LOCK-ctsmTMB due previously failed installation remove reinstalling","code":"install.packages(\"ctsmTMB\", type=\"source\") remotes::install_github(repo=\"phillipbvetter/ctsmTMB\", dependencies=TRUE) install.packages('ctsmTMB', repos = c('https://phillipbvetter.r-universe.dev'), type=\"source\") # Enter the path on your system enter.your.path <- \"/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library/00LOCK-ctsmTMB\" unlink(enter.your.path, recursive = TRUE)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"test-installation","dir":"","previous_headings":"","what":"Test Installation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"installed package good idea test whether TMB C++ compilation works. able run examples without compilation errors: information see TMB GitHub associated installation instructions.","code":"library(TMB) runExample(all=TRUE)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can visit package webpage browse vignettes example uses, particular see Getting Started.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can access documentation methods methods documentation also available package homepage.","code":"?ctsmTMB"},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"code-example---inference-in-1d-ornstein-uhlenbeck-process","dir":"","previous_headings":"","what":"Code Example - Inference in 1D Ornstein-Uhlenbeck Process","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"consider estimating parameters modified Ornstein-Uhlenbeck process dxt=θ(μ+ut−xt)dt+σxdBt dx_{t} = \\theta \\left( \\mu + u_t - x_t \\right) dt + \\sigma_x dB_{t} stationary mean μ\\mu augmented addition time-varying input utu_{t}. observations remain linear Gaussian: yk=xtk+εtεt∼𝒩(0,σy2) y_{k} = x_{t_k} + \\varepsilon_{t} \\qquad \\varepsilon_{t} \\sim \\mathcal{N}\\left(0, \\sigma_{y}^2 \\right) code chunk simulates data process using Euler-Maruyama scheme, generates appropriate ctsmTMB model object, performs parameter estimation using Extended Kalman Filter (Linear Kalman Filter method='lkf' also used) inspects resulting residuals, moment predictions stochastic simulations.","code":"library(ctsmTMB)  ############################################################ # Data simulation ############################################################  # Simulate data using Euler Maruyama set.seed(20) true.pars = c(theta=10, mu=1, sigma_x=1, sigma_y=0.1) #  dt.sim = 1e-3 t.sim = seq(0,5,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) u.sim = cumsum(rnorm(length(t.sim),sd=0.05)) x.sim = 3 for(i in 1:(length(t.sim)-1)) {   x.sim[i+1] = x.sim[i] + true.pars[\"theta\"]*(true.pars[\"mu\"]-x.sim[i]+u.sim[i])*dt.sim + true.pars[\"sigma_x\"]*dw[i] } df.sim <- data.frame(   t = t.sim,   u = u.sim,   x = x.sim )  # Extract simulation at observations time points, and create observations by adding noise dt.obs = 1e-2 ids = seq(1,length(t.sim),by=round(dt.obs / dt.sim)) df.obs <- df.sim[ids,] df.obs$y = df.obs$x + true.pars[\"sigma_y\"] * rnorm(nrow(df.obs))  ############################################################ # Model creation ############################################################  # Create model object model = ctsmTMB$new()  # Add system equations model$addSystem(   dx ~ theta * (mu-x+u) * dt + sigma_x*dw )  # Add observation equations model$addObs(   y ~ x )  # Set observation equation variances model$setVariance(   y ~ sigma_y^2 )  # Add vector input model$addInput(u)  # Specify parameter initial values and lower/upper bounds in estimation model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = c(initial=1e-1, lower=1e-10, upper=30) )  # Set initial state mean and covariance model$setInitialState(list(x.sim[1], 1e-1*diag(1)))   ############################################################ # Model estimation ############################################################  # Carry out estimation with default settings (extended kalman filter) fit <- model$estimate(df.obs, method=\"ekf\")  # Check parameter estimates against truth fitted.pars <- fit$par.fixed cbind(true.pars, fitted.pars, difference=true.pars - fitted.pars)  par(mfrow=c(3,1)) # Plot prior predictions (1-step predictions) against simulation (truth) and observations (data) df.est <- cbind(fit$states$mean$prior, sd=fit$states$sd$prior$x) plot(x=df.est$t, y=df.est$x, type=\"n\", main=\"1-Step State Estimates vs Observations\", xlab=\"Time\", ylab=\"\",  ylim=c(-3,3)) polygon(c(df.est$t, rev(df.est$t)), c(df.est$x+1.96*df.est$sd, rev(df.est$x-1.96*df.est$sd)), col=\"grey70\", border=NA) lines(df.est$t, df.est$x, col=\"steelblue\", lwd=2) points(df.obs$t, df.obs$y, col=\"tomato\", pch=16, cex=0.7)  # Predict to obtain k-step-ahead predictions to see model forecasting ability pred.10step <- model$predict(df.obs, k.ahead=10, method=\"ekf\", return.k.ahead = 10)  # Plot 10 step predictions vs data dfp <- pred.10step$states[c(\"t.j\",\"x\",\"var.x\")] dfp[,4] <- sqrt(dfp[\"var.x\"]) names(dfp) <- c(\"t\",\"x\",\"var\",\"sd\") plot(x=dfp$t, y=dfp$x, type=\"n\", main=\"10 Step Predictions vs Observations\", xlab=\"Time\", ylab=\"\", ylim=c(-3,3)) polygon(c(dfp$t, rev(dfp$t)), c(dfp$x+1.96*dfp$sd, rev(dfp$x-1.96*dfp$sd)), col=\"grey70\", border=NA) lines(dfp$t, dfp$x, col=\"steelblue\", lwd=2) points(df.obs$t, df.obs$y, col=\"tomato\", pch=16, cex=0.7)  # Perform a full prediction i.e. without updating to data along the way dfp <- model$predict(df.obs, method=\"ekf\")$states  # Perform full simulations - 10 sample trajectories sdf <- model$simulate(df.obs, method=\"ekf\", n.sims=10)$states$x$i0 sdf.sim <- sdf[,6:ncol(sdf)] matplot(sdf$t.j, sdf.sim, type=\"l\", lty=\"solid\", col=\"grey70\", main=\"No Update Prediction and Simulations vs Observations\", xlab=\"Time\") lines(dfp$t.j, dfp$x, col=\"steelblue\", lwd=2) points(df.obs$t, df.obs$y, col=\"tomato\", pch=16, cex=0.7)  # Perform residual analysis p2 <- plot(fit)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/index.html","id":"bibliography","dir":"","previous_headings":"","what":"Bibliography","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"U. H. Thygesen K. Kristensen (2025), “Inference stochastic differential equations using Laplace approximation: Demonstration examples”. : arXiv:2503.21358v2. S. Särkkä, “Unscented Kalman Filtering State Estimation Continuous-Time Nonlinear Systems”. : IEEE Transactions Automatic Control, 52(9), 1631-1641.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/Ornstein.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","title":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","text":"data simulated using standard Euler-Maruyama method. simulated process governed SDE #' dx ~ theta * (mu + u - x) * dt + sigma_x * dw parameters used simulation theta = 2, mu = 0.5, sigma_x = 1.358, sigma_y = 1e-8 simulation time-step 1e-3, observation time-step 1e-1. simulation taken t = 0..20","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/Ornstein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","text":"","code":"Ornstein"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/Ornstein.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","text":"data frame 201 rows 3 columns. columns represent variables: t (time), y (observation) u (input).","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"following public methods used construct stochastic state space model system, consisting set stochastic differential equations (SDEs), one algebraic observation equations (AOEs). AOEs used infer information value (latent) states governed SDEs, thus must functions least one state.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"function returns object class R6 ctsmTMB, can used define stochastic state space system.","code":""},{"path":[]},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"ctsmTMB$new() ctsmTMB$.private() ctsmTMB$getPrivateFields() ctsmTMB$getPrivate() ctsmTMB$setTrainingMethod() ctsmTMB$addSystem() ctsmTMB$addObs() ctsmTMB$setVariance() ctsmTMB$addInput() ctsmTMB$setParameter() ctsmTMB$setAlgebraics() ctsmTMB$setInitialState() ctsmTMB$setInitialVarianceScaling() ctsmTMB$setLamperti() ctsmTMB$setModelname() ctsmTMB$setMAP() ctsmTMB$setAdvancedSettings() ctsmTMB$getSystems() ctsmTMB$getObservations() ctsmTMB$getVariances() ctsmTMB$getAlgebraics() ctsmTMB$getInitialState() ctsmTMB$getParameters() ctsmTMB$getTimers() ctsmTMB$getEstimate() ctsmTMB$getLikelihood() ctsmTMB$getPrediction() ctsmTMB$getSimulation() ctsmTMB$filter() ctsmTMB$smoother() ctsmTMB$estimate() ctsmTMB$likelihood() ctsmTMB$predict() ctsmTMB$simulate() ctsmTMB$print() ctsmTMB$clone()","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Initialize private fields","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$new()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-private-","dir":"Reference","previous_headings":"","what":"Method .private()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Extract private fields ctsmTMB model object. Primarily used debugging.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$.private()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getprivatefields-","dir":"Reference","previous_headings":"","what":"Method getPrivateFields()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Extract private fields ctsmTMB model object. Primarily used debugging.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getPrivateFields()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getprivate-","dir":"Reference","previous_headings":"","what":"Method getPrivate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Extract private fields ctsmTMB model object. Primarily used debugging.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getPrivate()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-settrainingmethod-","dir":"Reference","previous_headings":"","what":"Method setTrainingMethod()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set training method","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setTrainingMethod(full.prediction)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"full.prediction boolean whether train full prediction data, rather 1-step predictions","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-addsystem-","dir":"Reference","previous_headings":"","what":"Method addSystem()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define stochastic differential equation(s) form d<state> ~ f(t,<states>, <inputs>) * dt + g(t, <states>, <inputs>) * dw","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addSystem(form, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying stochastic differential equation ... additional formulas similar form specifying multiple equations .","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-addobs-","dir":"Reference","previous_headings":"","what":"Method addObs()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define algebraic observation equations form <observation> ~ h(t, <states>, <inputs>) + e) h observation function, e normally distributed noise zero mean. function specifies observation name, mean h.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addObs(form, ..., obsnames = NULL)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying observation equation ... additional formulas similar form specifying multiple equations . obsnames character vector specifying name observation. used left-hand side form consists just single variable (class 'call').","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setvariance-","dir":"Reference","previous_headings":"","what":"Method setVariance()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Specify variance observation equation. defined observation variable y e.g. addObs(y ~ h(t,<states>,<inputs>) perturbed Gaussian noise zero mean variance -specified using setVariance(y ~ p(t,<states>,<inputs>). can instance declare setVariance(y ~ sigma_x^2 sigma_x fixed effect parameter declared setParameter.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setVariance(form, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula class specifying observation equation added system. ... additional formulas identical form specify multiple observation equations time.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-addinput-","dir":"Reference","previous_headings":"","what":"Method addInput()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables data inputs Declare whether variable contained system, observation observation variance equations input variable. e.g. system equation contains input variable u declared using addInput(u). input u must contained data.frame .data provided calling estimate predict methods.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addInput(...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... variable names specifies name input variables defined system.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setparameter-","dir":"Reference","previous_headings":"","what":"Method setParameter()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer guess, well lower / upper bounds optimization. two ways declare parameters: can declare parameters using formulas .e. setParameter( theta = c(1,0,10), mu = c(0,-10,10) ). first value initial value optimizer, second value lower optimization bound third value upper optimization bound. can provide 3-column matrix rows corresponds different parameters, parameter names provided rownames matrix. columns values corresponds description vector format .","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setParameter(...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... named vector matrix described .","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setalgebraics-","dir":"Reference","previous_headings":"","what":"Method setAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Add algebraic relations. Algebraic relations convenient way transform parameters equations. Ornstein-Uhlenbeck process rate parameter theta always positive, estimation log-domain good idea. Instead writing exp(theta) directly system equation one can transform log domain using algebraic relation setAlgebraics(theta ~ exp(logtheta)). instances theta replaced exp(logtheta) compiling C++ function. Note must provide values logtheta now instead theta declaring parameters setParameter","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setAlgebraics(form, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form algebraic formula ... additional formulas","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setinitialstate-","dir":"Reference","previous_headings":"","what":"Method setInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialState(initial.state)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setinitialvariancescaling-","dir":"Reference","previous_headings":"","what":"Method setInitialVarianceScaling()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scalar value multiplied onto estimated initial state covariance matrix. scaling applied initial state/cov estimated, set user.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialVarianceScaling(scaling)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scaling numeric scalar value.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setlamperti-","dir":"Reference","previous_headings":"","what":"Method setLamperti()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set Lamperti Transformation provided system equations state dependent diffusion available ways advantageous perform transformation remove state dependence. comes cost complicated drift function. following types state-dependence currently supported 'identity' - diffusion state-independent (default) 'log' - diffusion proportional x * dw 'logit' - diffusion proportional x * (1-x) * dw 'sqrt-logit' - diffusion proportional sqrt(x * (1-x)) * dw","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setLamperti(transforms, states = NULL)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"transforms character vector - one either \"identity, \"log\", \"logit\", \"sqrt-logit\" states vector state names specified transformations applied .","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setmodelname-","dir":"Reference","previous_headings":"","what":"Method setModelname()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set modelname used create C++ file TMB calling TMB::MakeADFun (negative log) likelihood function created directory specified setCppfilesDirectory method name <modelname>.cpp","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setModelname(name)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"name string defining model name.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setmap-","dir":"Reference","previous_headings":"","what":"Method setMAP()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function  evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setMAP(mean, cov)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"mean mean vector Gaussian prior parameter distribution cov covariance matrix Gaussian prior parameter distribution","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-setadvancedsettings-","dir":"Reference","previous_headings":"","what":"Method setAdvancedSettings()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function  evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setAdvancedSettings(   force.ad = TRUE,   rtmb.tapeconfig = NULL,   tmb.tapeconfig = NULL )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"force.ad boolean indicating whether use state space functions take advantage RTMB::AD(...,force=TRUE) hack reduces compilation time call MakeADFun 20%. breaks functionalities REPORT. rtmb.tapeconfig options passed TapeConfig. tmb.tapeconfig options passed config.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getsystems-","dir":"Reference","previous_headings":"","what":"Method getSystems()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve system equations.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSystems()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getobservations-","dir":"Reference","previous_headings":"","what":"Method getObservations()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation equations.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getObservations()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getvariances-","dir":"Reference","previous_headings":"","what":"Method getVariances()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation variances","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getVariances()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getalgebraics-","dir":"Reference","previous_headings":"","what":"Method getAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve algebraic relations","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getAlgebraics()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getinitialstate-","dir":"Reference","previous_headings":"","what":"Method getInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getInitialState()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getparameters-","dir":"Reference","previous_headings":"","what":"Method getParameters()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Get initial (estimated) parameters.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getParameters(type = \"all\", value = \"all\")"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"type one \"\", free\" \"fixed\" parameters. value one \"\", initial\", \"estimate\", \"lower\" \"upper\"","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-gettimers-","dir":"Reference","previous_headings":"","what":"Method getTimers()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially timers","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getTimers()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getestimate-","dir":"Reference","previous_headings":"","what":"Method getEstimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getEstimate()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getlikelihood-","dir":"Reference","previous_headings":"","what":"Method getLikelihood()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getLikelihood()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getprediction-","dir":"Reference","previous_headings":"","what":"Method getPrediction()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getPrediction()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-getsimulation-","dir":"Reference","previous_headings":"","what":"Method getSimulation()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSimulation()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-filter-","dir":"Reference","previous_headings":"","what":"Method filter()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform state filtering (smoothing 'laplace' method)","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$filter(   data,   pars = NULL,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = NULL,   ukf.hyperpars = c(1, 0, 3),   initial.state = self$getInitialState(),   laplace.residuals = FALSE,   estimate.initial.state = FALSE,   use.cpp = FALSE,   silent = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate method character vector specifying filtering method used state/likelihood calculations. Must one either \"lkf\", \"ekf\", \"laplace\". ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residuals natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approximation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 ukf.hyperpars hyperparameters alpha, beta, kappa used sigma points weights construction Unscented Kalman Filter. initial.state named list two entries 'x0' 'p0' containing initial state covariance state laplace.residuals boolean - whether calculate one-step ahead residuals using method oneStepPredict. estimate.initial.state boolean value. TRUE initial state covariance matrices estimated stationary solution linearized mean covariance differential equations. system contains time-varying inputs, first element used. use.cpp boolean indicate whether use C++ perform calculations silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-smoother-","dir":"Reference","previous_headings":"","what":"Method smoother()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform state filtering (smoothing 'laplace' method)","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-29","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$smoother(   data,   pars = NULL,   method = \"ekf\",   ode.solver = \"euler\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = NULL,   initial.state = self$getInitialState(),   laplace.residuals = FALSE,   estimate.initial.state = FALSE,   silent = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate method character vector specifying filtering method used state/likelihood calculations. Must one either \"lkf\", \"ekf\", \"laplace\". ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residuals natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approximation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 initial.state named list two entries 'x0' 'p0' containing initial state covariance state laplace.residuals boolean - whether calculate one-step ahead residuals using method oneStepPredict. estimate.initial.state boolean value. TRUE initial state covariance matrices estimated stationary solution linearized mean covariance differential equations. system contains time-varying inputs, first element used. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-estimate-","dir":"Reference","previous_headings":"","what":"Method estimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Estimate fixed effects parameters specified model.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-30","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$estimate(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = NULL,   ukf.hyperpars = c(1, 0, 3),   initial.state = self$getInitialState(),   trace = 10,   control = list(trace = trace, iter.max = 1e+05, eval.max = 1e+05),   use.hessian = FALSE,   report = TRUE,   laplace.residuals = FALSE,   unconstrained.optim = FALSE,   estimate.initial.state = FALSE,   silent = FALSE,   compile = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector specifying filtering method used state/likelihood calculations. Must one either \"lkf\", \"ekf\", \"laplace\". ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residuals natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approximation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 ukf.hyperpars hyperparameters alpha, beta, kappa used sigma points weights construction Unscented Kalman Filter. initial.state named list two entries 'x0' 'p0' containing initial state covariance state trace integer passed control determines number steps print-optimization (use 0 disable tracing print-outs). control list control parameters parsed nlminb control argument. See ?stats::nlminb information use.hessian boolean value. default (TRUE) causes optimization algorithm stats::nlminb use fixed effects hessian (negative log) likelihood performing optimization. feature available kalman filter methods without random effects. report boolean - whether report filtered states, observations residuals. laplace.residuals boolean - whether calculate one-step ahead residuals using method oneStepPredict. unconstrained.optim boolean value. TRUE optimization carried unconstrained .e. without parameter bounds specified setParameter. estimate.initial.state boolean value. TRUE initial state covariance matrices estimated stationary solution linearized mean covariance differential equations. system contains time-varying inputs, first element used. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. compile boolean (re)compiling objective C++ file, used methods ending _cpp. ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-likelihood-","dir":"Reference","previous_headings":"","what":"Method likelihood()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Construct extract function handlers negative log likelihood function. handlers TMB's MakeADFun constructed returned. enables user e.g. choose optimization algorithm, just control optimization workflow.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-31","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$likelihood(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = NULL,   ukf.hyperpars = c(1, 0, 3),   initial.state = self$getInitialState(),   estimate.initial.state = FALSE,   silent = FALSE,   compile = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector specifying filtering method used state/likelihood calculations. Must one either \"lkf\", \"ekf\", \"laplace\". ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep time-step used filtering schemes. time-step two different uses depending chosen method. Kalman Filters: time-step used numerically solving moment differential equations. Laplace Approximation: time-step used Euler-Maruyama simulation scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residuals natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approximation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 ukf.hyperpars hyperparameters alpha, beta, kappa used sigma points weights construction Unscented Kalman Filter. initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate.initial.state boolean value. TRUE initial state covariance matrices estimated stationary solution linearized mean covariance differential equations. system contains time-varying inputs, first element used. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. compile boolean (re)compiling objective C++ file, used methods ending _cpp. ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-predict-","dir":"Reference","previous_headings":"","what":"Method predict()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-32","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$predict(   data,   pars = NULL,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   k.ahead = nrow(data) - 1,   return.k.ahead = 0:k.ahead,   return.covariance = TRUE,   ukf.hyperpars = c(1, 0, 3),   initial.state = self$getInitialState(),   estimate.initial.state = private$estimate.initial,   use.cpp = FALSE,   silent = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. method prediction method ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance boolean value indicate whether covariance (instead correlation) returned. ukf.hyperpars hyperparameters alpha, beta, kappa used sigma points weights construction Unscented Kalman Filter. initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate.initial.state bool - stationary estimation initial mean covariance use.cpp boolean indicate whether use C++ perform calculations silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-simulate-","dir":"Reference","previous_headings":"","what":"Method simulate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-33","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$simulate(   data,   pars = NULL,   use.cpp = FALSE,   cpp.seed = NULL,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   simulation.timestep = diff(data$t),   k.ahead = nrow(data) - 1,   return.k.ahead = 0:k.ahead,   n.sims = 100,   ukf.hyperpars = c(1, 0, 3),   initial.state = self$getInitialState(),   estimate.initial.state = private$estimate.initial,   silent = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-19","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. use.cpp boolean indicate whether use C++ perform calculations cpp.seed integer seed value control RNG normal draws C++ side. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continuous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continuous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute Jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. simulation.timestep timestep used euler-maruyama scheme k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. n.sims number simulations ukf.hyperpars hyperparameters alpha, beta, kappa used sigma points weights construction Unscented Kalman Filter. initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate.initial.state bool - stationary estimation initial mean covariance silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. ... additional arguments return.covariance boolean value indicate whether covariance (instead correlation) returned.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Function print model object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-34","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$print()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"objects class cloneable method.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"usage-35","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$clone(deep = FALSE)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"arguments-20","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"deep Whether make deep clone.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/ctsmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # adding a single system equations model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw)  # adding an observation equation and setting variance model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2)  # add model input model$addInput(u)  # add parameters model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 )  # set the model initial state model$setInitialState(list(1,1e-1))  # extract the likelihood handlers nll <- model$likelihood(data=Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Finished!  # calculate likelihood, gradient and hessian w.r.t parameters nll$fn(nll$par) #> [1] 160.3533 nll$gr(nll$par) #>          [,1]      [,2]      [,3] #> [1,] 31.37158 -38.64846 -191.7731 nll$he(nll$par) #>           [,1]      [,2]      [,3] #> [1,]  45.81706 -66.59203 -82.08423 #> [2,] -66.59203  19.98320  77.29517 #> [3,] -82.08423  77.29517 972.62925  # estimate the parameters using an extended kalman filter fit <- model$estimate(data=Ornstein) #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.008 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # perform moment predictions pred <- model$predict(data=Ornstein) #> Checking and setting data... #> Predicting with R... #> Returning results... #> Finished!  # perform stochatic simulations sim <- model$simulate(data=Ornstein, n.sims=10) #> Checking and setting data... #> Simulating with R... #> Returning results... #> Finished."},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/new.model.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ctsmTMB model faster avoiding $... — new.model","title":"Create a ctsmTMB model faster avoiding $... — new.model","text":"Create ctsmTMB model faster avoiding $...","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/new.model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ctsmTMB model faster avoiding $... — new.model","text":"","code":"new.model()"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/new.model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a ctsmTMB model faster avoiding $... — new.model","text":"Print ctsmTMB model object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"function creates residual plots estimated ctsmTMB object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"","code":"# S3 method for class 'ctsmTMB.fit' plot(   x,   print.plot = 1,   type = \"residuals\",   state.type = \"prior\",   against.obs = NULL,   ggtheme = getggplot2theme(),   ylims = c(NA, NA),   residual.burnin = 0L,   residual.vs.obs.and.inputs = FALSE,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"x R6 ctsmTMB fit object print.plot single integer determining element states/observations (depending argument type). value 0 means plot anything. type character vector either 'residuals' 'states' determining plot. state.type character vector either 'prior', 'posterior' 'smoothed' determining kind states plot. .obs name observation plot state predictions . ggtheme ggplot2 theme use creating ggplot. ylims limits y-axis residual time-series plot residual.burnin integer N remove first N residuals residual.vs.obs..inputs residual plots also include new window time-series plots residuals, associated observations inputs ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"(list ) ggplot residual plot(s)","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.008 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # plot residuals if (FALSE) plot(fit) # \\dontrun{} plot(fit)  # plot filtered states if (FALSE) plot(fit, type=\"states\") # \\dontrun{}"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"Plot k-step predictions ctsmTMB prediction object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"","code":"# S3 method for class 'ctsmTMB.pred' plot(   x,   y,   k.ahead = unique(x[[\"states\"]][[\"k.ahead\"]]),   state.name = NULL,   type = \"states\",   against = NULL,   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"x ctsmTMB.pred object y used k.ahead integer indicating k-ahead predictions plot state.name string indicating states plot type one 'states' 'observations', plot name observations plot predictions ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"plot predicted states","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.pred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.008 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # perform moment predictions pred <- model$predict(Ornstein) #> Checking and setting data... #> Predicting with R... #> Returning results... #> Finished!  # plot the k.ahead=10 predictions plot(pred, against=\"y.data\")   # plot filtered states plot(fit, type=\"states\", against=\"y\")"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","title":"Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"Plot profile likelihood ctsmTMB object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"","code":"# S3 method for class 'ctsmTMB.profile' plot(x, y, include.opt = TRUE, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"x profile.ctsmTMB object y use include.opt boolean indicates whether include total likelihood optimizer plot. ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/plot.ctsmTMB.profile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.007 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # calculate profile likelihood # out <- profile(fit,parlist=list(theta=NULL)) out <- profile(fit,parlist=list(theta=NULL, mu=NULL)) #> Iteration: 1 / 100  #> Iteration: 2 / 100  #> Iteration: 3 / 100  #> Iteration: 4 / 100  #> Iteration: 5 / 100  #> Iteration: 6 / 100  #> Iteration: 7 / 100  #> Iteration: 8 / 100  #> Iteration: 9 / 100  #> Iteration: 10 / 100  #> Iteration: 11 / 100  #> Iteration: 12 / 100  #> Iteration: 13 / 100  #> Iteration: 14 / 100  #> Iteration: 15 / 100  #> Iteration: 16 / 100  #> Iteration: 17 / 100  #> Iteration: 18 / 100  #> Iteration: 19 / 100  #> Iteration: 20 / 100  #> Iteration: 21 / 100  #> Iteration: 22 / 100  #> Iteration: 23 / 100  #> Iteration: 24 / 100  #> Iteration: 25 / 100  #> Iteration: 26 / 100  #> Iteration: 27 / 100  #> Iteration: 28 / 100  #> Iteration: 29 / 100  #> Iteration: 30 / 100  #> Iteration: 31 / 100  #> Iteration: 32 / 100  #> Iteration: 33 / 100  #> Iteration: 34 / 100  #> Iteration: 35 / 100  #> Iteration: 36 / 100  #> Iteration: 37 / 100  #> Iteration: 38 / 100  #> Iteration: 39 / 100  #> Iteration: 40 / 100  #> Iteration: 41 / 100  #> Iteration: 42 / 100  #> Iteration: 43 / 100  #> Iteration: 44 / 100  #> Iteration: 45 / 100  #> Iteration: 46 / 100  #> Iteration: 47 / 100  #> Iteration: 48 / 100  #> Iteration: 49 / 100  #> Iteration: 50 / 100  #> Iteration: 51 / 100  #> Iteration: 52 / 100  #> Iteration: 53 / 100  #> Iteration: 54 / 100  #> Iteration: 55 / 100  #> Iteration: 56 / 100  #> Iteration: 57 / 100  #> Iteration: 58 / 100  #> Iteration: 59 / 100  #> Iteration: 60 / 100  #> Iteration: 61 / 100  #> Iteration: 62 / 100  #> Iteration: 63 / 100  #> Iteration: 64 / 100  #> Iteration: 65 / 100  #> Iteration: 66 / 100  #> Iteration: 67 / 100  #> Iteration: 68 / 100  #> Iteration: 69 / 100  #> Iteration: 70 / 100  #> Iteration: 71 / 100  #> Iteration: 72 / 100  #> Iteration: 73 / 100  #> Iteration: 74 / 100  #> Iteration: 75 / 100  #> Iteration: 76 / 100  #> Iteration: 77 / 100  #> Iteration: 78 / 100  #> Iteration: 79 / 100  #> Iteration: 80 / 100  #> Iteration: 81 / 100  #> Iteration: 82 / 100  #> Iteration: 83 / 100  #> Iteration: 84 / 100  #> Iteration: 85 / 100  #> Iteration: 86 / 100  #> Iteration: 87 / 100  #> Iteration: 88 / 100  #> Iteration: 89 / 100  #> Iteration: 90 / 100  #> Iteration: 91 / 100  #> Iteration: 92 / 100  #> Iteration: 93 / 100  #> Iteration: 94 / 100  #> Iteration: 95 / 100  #> Iteration: 96 / 100  #> Iteration: 97 / 100  #> Iteration: 98 / 100  #> Iteration: 99 / 100  #> Iteration: 100 / 100   # plot profile grDevices::dev.new() plot(out)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"Basic print objects ctsmTMB fit objects","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"","code":"# S3 method for class 'ctsmTMB.fit' print(x, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"x ctsmTMB fit object ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"Print ctsmTMB fit object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.013 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # print fit print(fit) #> Coefficent Matrix  #>         Estimate Std. Error t value  Pr(>|t|)     #> theta   5.140485   0.539245  9.5327 < 2.2e-16 *** #> mu      3.005177   0.056661 53.0380 < 2.2e-16 *** #> sigma_x 1.271765   0.071374 17.8183 < 2.2e-16 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of ctsmTMB objects — print.ctsmTMB","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"Basic print ctsmTMB objects","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"","code":"# S3 method for class 'ctsmTMB' print(x, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"x object class 'ctsmTMB' ... additional arguments (use)","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"Print ctsmTMB model object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/print.ctsmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # print empty model print(model) #> This ctsmTMB model contains:               #> States       0 #> Diffusions   0 #> Observations 0 #> Inputs       1 #> Parameters   0  # add elements to model and see new print model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) print(model) #> This ctsmTMB model contains:               #> States       1 #> Diffusions   1 #> Observations 1 #> Inputs       2 #> Parameters   4 #>  #> System Equations: #> \t dx ~ theta * (mu + u - x) * dt + sigma_x * dw  #>  #> Observation Equations: #> \t y:  y ~ x + e \t e ~ N(0, sigma_y^2)  #>  #> Inputs: #> \t u #>  #> Parameters: #> \t theta, mu, sigma_x, sigma_y #>  #> Fixed Parameters: #> \t sigma_y"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/profile.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","title":"Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"Performs full multi-dimensional profile likelihood calculations","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/profile.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"","code":"# S3 method for class 'ctsmTMB.fit' profile(   fitted,   parlist,   grid.size = rep(10, length(parlist)),   grid.qnt = rep(3, length(parlist)),   hessian = FALSE,   silent = FALSE,   control = list(trace = 0, iter.max = 1000, eval.max = 1000),   ... )"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/profile.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"fitted ctmsTMB fit object parlist named-list parameters profile . user can either supply grid-values list leave empty. one list empty grid-values calculated using estimated parameter mean value standard deviation. grid.size vector length(parlist) indicating number grid-points along parameter direction. used parlist empty. grid.qnt vector length(parlist) determining width grid points mean value multiples standard deviation. hessian boolean indicating whether use hessian profile optimization. silent boolean whether mute current iteration number control argument. control list optimization output controls (see nlminb) ... various arguments (use)","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/profile.ctsmTMB.fit.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"implementation modified https://github.com/kaskr/adcomp/blob/master/TMB/R/tmbprofile.R","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/profile.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.008 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # calculate profile likelihood out <- profile(fit,parlist=list(theta=NULL)) #> Iteration: 1 / 10  #> Iteration: 2 / 10  #> Iteration: 3 / 10  #> Iteration: 4 / 10  #> Iteration: 5 / 10  #> Iteration: 6 / 10  #> Iteration: 7 / 10  #> Iteration: 8 / 10  #> Iteration: 9 / 10  #> Iteration: 10 / 10"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/summary.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"Basic summary ctsmTMB fit object","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/summary.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"","code":"# S3 method for class 'ctsmTMB.fit' summary(object, correlation = FALSE, ...)"},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/summary.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"object ctsmTMB fit object correlation boolean indicating whether display parameter correlation structure ... additional arguments","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/summary.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"summary estimated ctsmTMB model fit","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/reference/summary.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Checking model components... #> Checking and setting data... #> Constructing objective function and derivative tables... #> Minimizing the negative log-likelihood... #>   0:     160.35328:  1.00000  1.50000  1.00000 #>  10:     89.603625:  2.58436  2.91384  1.15608 #> \t Optimization finished!: #>             Elapsed time: 0.007 seconds. #>             The objective value is: 7.387879e+01 #>             The maximum gradient component is: 9.9e-08 #>             The convergence message is: relative convergence (4) #>             Iterations: 19 #>             Evaluations: Fun: 29 Grad: 20 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # print model summary summary(fit, correlation=TRUE) #> Coefficent Matrix  #>         Estimate Std. Error t value  Pr(>|t|)     #> theta   5.140485   0.539245  9.5327 < 2.2e-16 *** #> mu      3.005177   0.056661 53.0380 < 2.2e-16 *** #> sigma_x 1.271765   0.071374 17.8183 < 2.2e-16 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Correlation Matrix #>         theta mu    sigma_x #> theta    1.00               #> mu      -0.19  1.00         #> sigma_x  0.45 -0.09  1.00"},{"path":"https://github.com/phillipbvetter/ctsmTMB/news/index.html","id":"ctsmtmb-102---","dir":"Changelog","previous_headings":"","what":"ctsmTMB 1.0.2 (????-??-??)","title":"ctsmTMB 1.0.2 (????-??-??)","text":"Previously ‘ekf’ support prediction simulation. Nowe ‘lkf’ ‘ukf’ also supported R Rcpp. New method ‘setAdvancedSettings’ various extra features (force.ad tape configurations TMB::config RTMB::TapeConfig) New method ‘setTrainingMethod’ enables training likelihood ODE minimizing distance full prediction - still need support k-step.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/news/index.html","id":"ctsmtmb-101-2025-08-27","dir":"Changelog","previous_headings":"","what":"ctsmTMB 1.0.1 (2025-08-27)","title":"ctsmTMB 1.0.1 (2025-08-27)","text":"CRAN release: 2025-08-27 Internal large code-clean-Rcpp RNG simulations now use ‘zigg’ instead ‘RcppZiggurator’ thereby avoiding need ‘SystemRequirements: GNU GSL’. Removed RTMBode possibilities. Renamed smoothing method ‘laplace2’ ‘laplace.thygesen’. Fixed simple typo bug results reporting functions. Added implicit euler ODE solver ‘ode.solver’ options.","code":""},{"path":"https://github.com/phillipbvetter/ctsmTMB/news/index.html","id":"ctsmtmb-100-2025-04-08","dir":"Changelog","previous_headings":"","what":"ctsmTMB 1.0.0 (2025-04-08)","title":"ctsmTMB 1.0.0 (2025-04-08)","text":"CRAN release: 2025-04-08 Initial release","code":""}]
